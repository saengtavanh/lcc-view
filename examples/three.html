<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LCC ThreeJS Demo</title>
  <style>
    :root{
      --bg:#0f172a;--bg-2:#111827;--fg:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;
      --glass:rgba(15,23,42,.6);--glass-2:rgba(17,24,39,.92);
      --btn:rgba(255,255,255,.08);--btn-hover:rgba(255,255,255,.16);
      --shadow:0 8px 24px rgba(0,0,0,.35);--danger:#ef4444;
      --blue:#3b82f6;
    }
    html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#000}
    canvas{display:block}

    /* ---------- Main toolbar visibility ---------- */
    #main-toolbar.open{display:flex}
    #main-toolbar{display:none}

    /* ---------- UI bars ---------- */
    .ui{position:fixed;inset:0;pointer-events:none;z-index:10;display:flex;gap:12px}
    .toolbar{position:relative;top:10px;left:10px;display:flex;gap:8px;padding:6px;
      background:var(--glass);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.08);
      border-radius:10px;box-shadow:var(--shadow);pointer-events:auto;height:fit-content}
    /*.btn{display:inline-flex;align-items:center;justify-content:center;width:34px;height:34px;
      border-radius:9px;background:var(--btn);border:1px solid rgba(255,255,255,.06);
      cursor:pointer;transition:transform .08s ease,background .15s ease;user-select:none;color:var(--fg);position:relative}*/
    .btn{display:inline-flex;align-items:center;justify-content:center;width:34px;height:34px;
      border-radius:9px;
      cursor:pointer;transition:transform .08s ease,background .15s ease;user-select:none;color:var(--fg);position:relative}
    .btn:hover{background:var(--btn-hover)}
    .btn:active{transform:translateY(1px) scale(.98)}
    /*.btn.active{background:#3364ff;outline:2px solid var(--accent)}*/
    div.active img{background:#3364ff;outline:2px solid var(--accent)}
    .btn img{width:17px;height:17px;fill:none;stroke:var(--fg);stroke-width:2}

    /* ---------- Perspective submenu bubble (under the button) ---------- */
    .bubble{
      position:absolute;left:0;top:44px;display:none;flex-direction:column;gap:8px;
      pointer-events:auto;
    }
    .bubble.open{display:flex}
    .bubble .cluster{
      display:flex;gap:8px;padding:6px;background:var(--glass);
      border:1px solid rgba(255,255,255,.08);border-radius:10px;box-shadow:var(--shadow)
    }
    .bubble .btn{width:36px;height:36px}
    /*.bubble .btn.active{background:#3364ff}*/
    .bubble div.active img{background:#3364ff}
    .bubble .tip{align-self:center;margin-top:2px;background:rgba(0,0,0,.8);color:#fff;padding:4px 8px;border-radius:8px;
      font:12px/1.1 system-ui;border:1px solid rgba(255,255,255,.15)}

    /* ---------- Measure subbar ---------- */
    .measure-subbar{
      position:fixed;padding:6px;gap:6px;display:none;background:var(--glass);
      backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.08);border-radius:10px;
      box-shadow:var(--shadow);pointer-events:auto;z-index:12
    }
    .measure-subbar.open{display:flex}
    /*.chip{display:inline-flex;align-items:center;gap:6px;background:#0b0f1f;border:1px solid rgba(255,255,255,.12);
      color:#fff;border-radius:999px;padding:5px 8px;font:12px/1.1 system-ui,sans-serif;cursor:pointer}*/
    .chip{display:inline-flex;align-items:center;gap:6px;
      color:#fff;border-radius:999px;padding:5px 8px;font:12px/1.1 system-ui,sans-serif;cursor:pointer}
    /*.chip.active{outline:2px solid var(--accent);background:#1f2a4b}*/
    div.active img{outline:2px solid var(--accent);}
    div.active img:hover {background:#3364ff}

    /* ---------- Drawer ---------- */
    .drawer{
      position:fixed;width:360px;background:var(--glass-2);
      border:1px solid rgba(255,255,255,.08);border-radius:14px;
      box-shadow:0 24px 60px rgba(0,0,0,.45);pointer-events:auto;overflow:hidden;display:none;z-index:20
    }
    .drawer.open{display:flex;flex-direction:column}
    .drawer header{padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);font-weight:700;color:#fff}
    .drawer .body{padding:12px 14px;overflow:auto;max-height:70vh}
    .drawer::before{content:"";position:absolute;top:-8px;left:20px;width:16px;height:16px;background:var(--glass-2);
      border-left:1px solid rgba(255,255,255,.08);border-top:1px solid rgba(255,255,255,.08);transform:rotate(45deg)}

    .section{margin:10px 0;border-top:1px solid rgba(255,255,255,.08);padding-top:10px}
    .section:first-child{border-top:0;padding-top:0}
    .section h4{margin:0 0 10px;color:#e5e7eb;font:600 14px/1.2 system-ui}
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px 0}
    .label{color:#d1d5db;font-size:13px}

    .switch{position:relative;width:42px;height:22px;background:#374151;border-radius:999px;cursor:pointer;border:1px solid rgba(255,255,255,.08)}
    .switch::after{content:"";position:absolute;top:2px;left:2px;width:18px;height:18px;background:#fff;border-radius:50%;transition:transform .15s}
    .switch.on{background:#2563eb}.switch.on::after{transform:translateX(20px)}
    .switch input{display:none}

    .seg{display:inline-flex;background:#0b0f1f;border:1px solid rgba(255,255,255,.12);border-radius:10px;overflow:hidden}
    .seg button{all:unset;color:#fff;padding:6px 10px;cursor:pointer;font:13px/1 system-ui}
    .seg button:not(:last-child){border-right:1px solid rgba(255,255,255,.08)}
    .seg button.active{background:#1f2a4b;outline:2px solid #3b82f6}

    .slider-wrap{padding:6px 2px}
    .ticks{display:flex;align-items:center;gap:12px}
    .ticks input[type=range]{width:100%}
    .tick-labels{display:flex;justify-content:space-between;color:#9ca3af;font-size:12px;margin-top:6px}
    input[type=range]{-webkit-appearance:none;height:4px;background:#334155;border-radius:999px;outline:none}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:#fff;border:2px solid #60a5fa}
    input[type=range]::-moz-range-thumb{width:16px;height:16px;border-radius:50%;background:#fff;border:2px solid #60a5fa}

    /* ---------- Overlays ---------- */
    .measure-layer{position:absolute;inset:0;pointer-events:none;z-index:18}
    #measure-svg{position:absolute;inset:0;pointer-events:none}
    .labels-layer{position:absolute;inset:0;pointer-events:none;z-index:19}

    .measure-label, .measure-label-area{
      position:absolute;transform:translate(-50%,-120%);
      padding:4px 8px;border-radius:8px;background:rgba(0,0,0,.8);
      border:1px solid rgba(255,255,255,.15);color:#fff;white-space:nowrap;
      font:12px/1.2 system-ui,sans-serif;pointer-events:auto;
    }
    .measure-label .meta, .measure-label-area .meta{display:inline}
    .measure-label .lbl-del, .measure-label-area .lbl-del{
      display:none;padding:2px 6px;border-radius:6px;background:rgba(239,68,68,.92);
      border:1px solid rgba(255,255,255,.2);font:11px/1.1 system-ui;cursor:pointer;margin-top:5px;
    }
    .measure-label:hover .lbl-del{display:block;}

    .pro-card{background:#0b0f1f;border:1px solid rgba(255,255,255,.25);box-shadow:0 6px 20px rgba(0,0,0,.45);
      padding:8px 10px;border-radius:12px;font:12px/1.25 system-ui,sans-serif;min-width:84px;color:#fff}
    .pro-title{font-weight:700;margin-bottom:4px}
    .pro-row{color:#93c5fd;font-size:12px}
    .leader{stroke:#ffffff;stroke-width:2;stroke-dasharray:4 6;opacity:.9}

    /* Loupe */
    .loupe{position:absolute;width:165px;height:165px;border-radius:50%;border:3px solid rgba(255,255,255,.9);
      overflow:hidden;pointer-events:none;z-index:25;display:none;box-shadow:0 8px 28px rgba(0,0,0,.45), inset 0 0 0 2px rgba(255,255,255,.12);
      background: radial-gradient(transparent 58%, rgba(0,0,0,.15) 60%)}
    .loupe-canvas{width:100%;height:100%;image-rendering:pixelated;filter:contrast(1.05) saturate(1.05)}

    /* ---------- Title badge ---------- */
    .page-title{
      top:6px;left:18px;z-index:11;background:#3364ff;color:#fff;font:600 16px/1.4 system-ui, sans-serif;
      padding:4px 12px;border-radius:4px;box-shadow:0 4px 16px rgba(0,0,0,.35);pointer-events:none;white-space:nowrap;
      transform:translateZ(0);display:none;
      align-content: center;
    }

    /* ---------- XYZ Gizmo ---------- */
    #gizmoCanvas{
      position:fixed;
      right:12px;
      top:72px;
      width:120px;
      height:120px;
      z-index:26;
      pointer-events:auto;
      cursor:pointer;
      touch-action:none;
    }

    /* ===============================
       HELP OVERLAY (new design)
    ================================*/
    .help-back{position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(3px);display:none;z-index:30}
    .help-back.open{display:block}
    .help-center{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:min(1100px,94vw);padding:0 10px;color:#fff;text-align:center;
    }
    .help-title{font:800 40px/1.1 system-ui;margin:0 0 18px}
    .help-close{
      position:absolute;right:min(24px,3vw);top:min(18px,2.4vh);background:transparent;border:0;color:#fff;
      width:44px;height:44px;border-radius:12px;cursor:pointer;display:flex;align-items:center;justify-content:center
    }
    .help-close:hover{background:rgba(255,255,255,.08)}

    /* Mode icon row */
    .help-modes{display:flex;gap:14px;justify-content:center;align-items:center;margin:8px 0 28px}
    .help-modes img{width: 50px; height: 50px;}
    .mode{
      width:48px;height:48px;border-radius:12px;border:1px solid rgba(255,255,255,.15);
      background:rgba(255,255,255,.06);display:inline-flex;align-items:center;justify-content:center;cursor:pointer
    }
    .mode svg{width:22px;height:22px;stroke:#fff;fill:none;stroke-width:2}
    .mode.active{background:#2663ff;border-color:#4f7dff;box-shadow:0 8px 30px rgba(51,100,255,.35)}

    /* Controls row */
    .help-controls{display:flex;flex-wrap:wrap;justify-content:center;gap:28px; width: max-content;}
    .help-controls-2{display:flex;flex-wrap:wrap;justify-content:center;gap:28px; }
    .control{display:flex;flex-direction:column;align-items:center;gap:14px;min-width:150px;justify-content: end;}
    .label-ctl{font:600 16px/1.2 system-ui;opacity:.95}

    /* Key blocks */
    .key{min-width:56px;height:56px;border-radius:12px;border:2px solid rgba(255,255,255,.85);
      display:inline-flex;align-items:center;justify-content:center;font:700 24px/1 system-ui;background:rgba(255,255,255,.08);
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.25)}
    .key.sm{min-width:48px;height:48px;font-size:20px}
    .row-keys{display:flex;gap:12px}
    .stack{display:flex;flex-direction:column;gap:12px}

    /* Mouse tile */
    .mouse{width:70px;height:90px;border-radius:40px;border:2px solid rgba(255,255,255,.9);
      position:relative}
    .wheel{position:absolute;left:50%;top:34px;transform:translateX(-50%);width:12px;height:18px;border-radius:8px;border:2px solid rgba(255,255,255,.9)}
    .arrow{font:900 28px/1 system-ui}
    .arrow.v{display:flex;flex-direction:column;align-items:center;gap:4px}
    .arrow.h{display:flex;align-items:center;gap:12px}

    @media (max-width:720px){
      .help-title{font-size:30px}
      .key{min-width:48px;height:48px;font-size:20px}
      .key.sm{min-width:40px;height:40px;font-size:18px}
    }
  

/* ---------- Password gate modal ---------- */
.pwd-modal{
  position:fixed; inset:0;
  background:rgba(0,0,0,.55);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1000;
  padding:18px;
}
.pwd-modal.open{display:flex;}
.pwd-card{
  width:min(420px, 100%);
  background:var(--glass-2);
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  box-shadow:0 24px 60px rgba(0,0,0,.55);
  overflow:hidden;
  color:var(--fg);
}
.pwd-card header{
  padding:12px 14px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  border-bottom:1px solid rgba(255,255,255,.08);
  font-weight:700;
}
.pwd-card .body{padding:14px;}
.pwd-card label{display:block;color:var(--muted);font-size:12px;margin-bottom:6px;}
.pwd-card input{
  width:100%;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.25);
  color:var(--fg);
  outline:none;
}
.pwd-hint{margin-top:8px;color:var(--muted);font-size:12px;}
.pwd-error{margin-top:10px;color:#fecaca;font-size:12px;min-height:16px;}
.pwd-actions{
  display:flex;
  gap:10px;
  justify-content:flex-end;
  margin-top:12px;
}
.pwd-btn{
  padding:9px 12px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.08);
  color:var(--fg);
  cursor:pointer;
}
.pwd-btn:hover{background:rgba(255,255,255,.12);}
.pwd-btn.primary{
  background:rgba(96,165,250,.20);
  border-color:rgba(96,165,250,.35);
}
.pwd-btn.primary:hover{background:rgba(96,165,250,.28);}

/* ---------- Locked / error message overlay ---------- */
.lock-msg{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.55);
  z-index:900;
  padding:18px;
}
.lock-msg .inner{
  width:min(520px, 100%);
  background:var(--glass-2);
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  box-shadow:0 24px 60px rgba(0,0,0,.55);
  color:var(--fg);
  padding:16px;
}
.lock-msg .lock-msg-text{color:var(--fg);font-size:14px;line-height:1.4;}
</style>
</head>
<body>
  <div class="ui" id="ui-root">
    <!-- Left small menu group -->
    <div class="toolbar" id="main-menu">
      <div id="btn-menu" aria-label="Menu" title="Menu">
        <img class="btn" src="../assets/menu.svg" alt="">
      </div>
    </div>

    <!-- Main toolbar -->
    <div class="toolbar open" id="main-toolbar">
      <div id="page-title" class="page-title"></div>
      <div  id="btn-locate" aria-label="Relocate" title="Relocate">
        <img class="btn" src="../assets/relocate.svg" alt="">
      </div>

      <!-- Perspective button with submenu -->
      <div style="position:relative">
        <div id="btn-perspective" aria-label="Perspective" title="Perspective">
          <img class="btn" id="fps-icon" src="../assets/first-person.svg" alt="">
          <img class="btn" id="pivot-icon" style="display: none;" src="../assets/privot.svg" alt="">
        </div>
        <div class="bubble" id="persp-bubble">
          <div class="cluster">
            <div id="mode-fps" title="First person" class="active">
              <img class="btn" src="../assets/first-person.svg" alt="">
            </div>
            <div id="mode-pivot" title="Pivot mode">
              <img class="btn" src="../assets/privot.svg" alt="">
            </div>
          </div>
          <div class="tip" id="persp-tip">First-person</div>
        </div>
      </div>

      <div  id="btn-switch-mode" aria-label="Switch to point cloud" title="Switch to point cloud">
        <img class="btn" src="../assets/point-view.svg" alt="">
      </div>
      <div id="btn-measure" aria-label="Measure" title="Measure">
        <img class="btn" src="../assets/measure.svg" alt="">
      </div>
      <div id="btn-annot" aria-label="Annotations" title="Annotations">
        <img class="btn" src="../assets/marking.svg" alt="">
      </div>
      <div id="btn-options" aria-label="Options" title="Options">
        <img class="btn" src="../assets/option.svg" alt="">
      </div>
      <div id="btn-help" aria-label="Help" title="Help">
        <img class="btn" src="../assets/help.svg" alt="">
      </div>
    </div>

    <!-- Measurement subbar -->
    <div class="measure-subbar" id="measure-subbar">
      <div class="active" id="mode-distance" aria-label="Distance" title="Distancs"><img class="btn" src="../assets/distance.svg" alt=""></div>
      <div id="mode-area"><img class="btn" src="../assets/area.svg" alt=""></div>
      <div class="chip" style="gap:10px">
        <div class="switch" id="sw-hide-history" title="Toggle measurement history visibility">
          <input type="checkbox" />
        </div>
        <span>Hide publisher history record</span>
      </div>
    </div>

    <!-- Options drawer -->
    <div class="drawer" id="drawer-options" role="dialog" aria-label="Options">
      <header>Options</header>
      <div class="body">
        <div class="section">
          <h4>General</h4>
          <div class="row"><div class="label">Collision</div><div class="switch on" id="sw-collision"><input type="checkbox" checked></div></div>
          <div class="row"><div class="label">Scanning Path</div><div class="switch" id="sw-scan"><input type="checkbox" id="opt-scan"></div></div>
        </div>

        <div class="section">
          <h4>Environment Settings</h4>
          <div class="seg" id="env-seg">
            <button data-v="none">None</button>
            <button class="active" data-v="env">Environment</button>
            <button data-v="skybox" disabled style="opacity:.45;cursor:not-allowed">Skybox</button>
          </div>
        </div>

        <div class="section">
          <h4>Rendering</h4>
          <div class="slider-wrap">
            <div class="ticks"><input id="render-slider" type="range" min="0" max="4" step="1" value="0" /></div>
            <div class="tick-labels"><span>Performance</span><span></span><span>Balance</span><span></span><span>Quality</span></div>
          </div>
        </div>

        <div class="section">
          <h4>Measurement</h4>
          <div class="row" style="align-items:flex-start;flex-direction:column;gap:8px">
            <div class="label">Unit System</div>
            <div class="seg" id="seg-system">
              <button class="active" data-sys="metric">Metric</button>
              <button data-sys="imperial">Imperial</button>
            </div>
          </div>
          <div class="row" style="align-items:flex-start;flex-direction:column;gap:8px">
            <div class="label">Distance</div>
            <div class="seg" id="seg-distance">
              <button class="active" data-unit="m">Meters</button>
              <button data-unit="cm">Centimeters</button>
            </div>
          </div>

          <div class="row">
            <div class="label">Pro Measurements</div>
            <div class="switch" id="sw-pro"><input type="checkbox"></div>
          </div>

          
        </div>
      </div>
    </div>
  </div>

  <!-- Measurement overlay -->
  <div id="measure-layer" class="measure-layer">
    <svg id="measure-svg" width="100%" height="100%">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
          <path d="M0 0 L10 5 L0 10 z" fill="rgba(255,255,255,.9)"/>
        </marker>
      </defs>
      <g id="areas-root"></g>
      <g id="segments-root"></g>
      <line id="preview-line" x1="0" y1="0" x2="0" y2="0" stroke="white" stroke-width="2"
            stroke-dasharray="6 6" marker-start="url(#arrow)" marker-end="url(#arrow)" style="display:none"/>
      <polygon id="preview-area-fill" fill="rgba(96,165,250,0.35)" stroke="none" style="display:none"/>
      <polyline id="preview-poly" fill="none" stroke="white" stroke-width="2" stroke-dasharray="6 6" style="display:none"/>
      <g id="crosshair" style="display:none">
        <circle cx="0" cy="0" r="120" fill="none" stroke="white" stroke-width="3" opacity="0.95"/>
        <line x1="-120" y1="0" x2="120" y2="0" stroke="white" stroke-width="2" />
        <line x1="0" y1="-120" x2="0" y2="120" stroke="white" stroke-width="2" />
        <circle cx="0" cy="0" r="6" fill="white"/>
      </g>
    </svg>
  </div>

  <!-- Labels layer (clickable) -->
  <div id="labels-layer" class="labels-layer"></div>

  <div id="loupe" class="loupe"><canvas id="loupeCanvas" class="loupe-canvas"></canvas></div>

  <!-- ===== HELP overlay (updated) ===== -->
  <div id="help" class="help-back" aria-hidden="true">
    <button class="help-close" id="help-close" aria-label="Close">
      <svg width="28" height="28" viewBox="0 0 24 24" stroke="#fff" fill="none" stroke-width="2"><path d="M6 6l12 12M18 6l-12 12"/></svg>
    </button>

    <div class="help-center">
      <h2 class="help-title">Help</h2>

      <!-- Mode icons row -->
      <div class="help-modes">
        <div  id="helpMode-fps" title="First person">
          <img class="btn" src="../assets/first-person.svg" alt="">
        </div>
        <div  id="helpMode-pivot" title="Pivot">
          <img class="btn" src="../assets/privot.svg" alt="">
        </div>
      </div>

      <!-- Controls tiles -->
      <div class="help-controls">
        <!-- WASD + QE -->
        <div class="control">
          <div class="arrow v">
            <img src="../assets/move.svg" alt="">
          </div>
          <div class="label-ctl">Move</div>
        </div>

        <div class="control">
          <div class="arrow v">
            <img src="../assets/up-down.svg" alt="">
          </div>
          <div class="label-ctl">Up &amp; Down</div>
        </div>

        <!-- Scroll to Zoom -->
        <div class="control">
          <div class="arrow v">
            <img src="../assets/scroll.svg" alt="">
          </div>
          <div class="label-ctl">Scroll to Zoom</div>
        </div>

        <!-- Sprint -->
        <div class="control">
          <div class="arrow v">
            <img src="../assets/shift.svg" alt="">
          </div>
          <div class="label-ctl">Sprint</div>
        </div>

        <!-- Rotate -->
        <div class="control">
          <div class="arrow h">
            <img src="../assets/rotate.svg" alt="">
          </div>
          <div class="label-ctl">Rotate</div>
        </div>

        <!-- Pan -->
        <div class="control">
          <div class="arrow h">
            <img src="../assets/pan.svg" alt="">
          </div>
          <div class="label-ctl">Pan</div>
        </div>
      </div>

      <div class="help-controls-2">
        
        <!-- Rotate -->
        <div class="control">
          <div class="arrow h">
            <img src="../assets/rotate.svg" alt="">
          </div>
          <div class="label-ctl">Rotate</div>
        </div>
        <!-- Scroll to Zoom -->
        <div class="control">
          <div class="arrow v">
            <img src="../assets/scroll.svg" alt="">
          </div>
          <div class="label-ctl">Scroll to Zoom</div>
        </div>


        <!-- Pan -->
        <div class="control">
          <div class="arrow h">
            <img src="../assets/pan.svg" alt="">
          </div>
          <div class="label-ctl">Pan</div>
        </div>
      </div>

    </div>
  </div>
  <!-- ===== /HELP overlay ===== -->

  <script type="importmap">
    {"imports":{
      "three":"./engine/three/three.module.js",
      "three/addons/":"./engine/three/jsm/"
    }}
  </script>

  <script type="module">
    import * as THREE from "three";
    import { FirstPersonControls } from "./engine/three/FirstPersonControls.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { LCCRender } from "../sdk/lcc-0.5.4.js";

    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0x000000);
    document.body.appendChild(renderer.domElement);

    /* ---------- XYZ GIZMO ---------- */
    const GIZMO_SIZE = 120;
    const gizmoRenderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    gizmoRenderer.setPixelRatio(window.devicePixelRatio);
    gizmoRenderer.setSize(GIZMO_SIZE,GIZMO_SIZE);
    gizmoRenderer.domElement.id = "gizmoCanvas";
    document.body.appendChild(gizmoRenderer.domElement);

    const gizmoScene = new THREE.Scene();
    const gizmoCamera = new THREE.PerspectiveCamera(40, 1, 0.1, 12);
    gizmoCamera.position.set(0, 0, 5.2);
    gizmoCamera.lookAt(0,0,0);

    function setGizmoSize(px=GIZMO_SIZE){
      gizmoRenderer.setPixelRatio(window.devicePixelRatio);
      gizmoRenderer.setSize(px, px);
      gizmoCamera.aspect = 1;
      gizmoCamera.updateProjectionMatrix();
    }

    const gizmoRoot = new THREE.Group();
    gizmoScene.add(gizmoRoot);

    function makeTextSprite(letter, color) {
      const c = document.createElement('canvas');
      c.width = c.height = 192;
      const ctx = c.getContext('2d');
      ctx.clearRect(0,0,192,192);
      ctx.beginPath(); ctx.arc(96,96,84,0,Math.PI*2); ctx.fillStyle = color; ctx.fill();
      ctx.fillStyle = '#ffffff'; ctx.font = 'bold 110px system-ui, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(letter, 96, 104);
      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
      const spr = new THREE.Sprite(mat); const s = 0.55; spr.scale.set(s,s,1);
      return spr;
    }
    function addAxis(dir, colorHex, letter){
      const color = new THREE.Color(colorHex);
      const len = 1.25, radius = 0.06;
      const cylGeo = new THREE.CylinderGeometry(radius, radius, len, 24);
      const cylMat = new THREE.MeshBasicMaterial({ color });
      const shaft = new THREE.Mesh(cylGeo, cylMat);
      shaft.userData.__axis = { letter, dir: dir.clone().normalize() };
      const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
      shaft.quaternion.copy(q); shaft.position.copy(dir).multiplyScalar(len/2); gizmoRoot.add(shaft);
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(radius*1.35, 24, 16), new THREE.MeshBasicMaterial({ color }));
      sphere.userData.__axis = { letter, dir: dir.clone().normalize() };
      sphere.position.copy(dir).multiplyScalar(len); gizmoRoot.add(sphere);
      const spr = makeTextSprite(letter, color.getStyle());
      spr.userData.__axis = { letter, dir: dir.clone().normalize() }; spr.position.copy(dir).multiplyScalar(len + 0.25); gizmoRoot.add(spr);
    }
    addAxis(new THREE.Vector3(1,0,0), 0xff4d4d, 'X');
    addAxis(new THREE.Vector3(0,1,0), 0x6ee76e, 'Y');
    addAxis(new THREE.Vector3(0,0,1), 0x5da2ff, 'Z');
// --- Click XYZ gizmo to snap view ---
    const gizmoRaycaster = new THREE.Raycaster();
    const gizmoPointer = new THREE.Vector2();

    function getActiveTarget(){
      const orbit = window.__orbit__;
      if (orbit && orbit.target) return orbit.target.clone();
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      return camera.position.clone().add(dir.multiplyScalar(1));
    }

    function snapViewToAxis(axisDir){
      const dir = axisDir.clone().normalize();
      const orbit = window.__orbit__;
      const fp = window.__fp__;
      const target = getActiveTarget();
      let dist = camera.position.distanceTo(target);
      if (!isFinite(dist) || dist < 0.001) dist = 6;

      // Set a stable up vector (special case for top/bottom views)
      if (Math.abs(dir.y) > 0.95){
        camera.up.set(0, 0, dir.y > 0 ? -1 : 1);
      } else {
        camera.up.set(0, 1, 0);
      }

      camera.position.copy(target.clone().add(dir.multiplyScalar(dist)));
      camera.lookAt(target);
      camera.updateProjectionMatrix();

      if (orbit){
        orbit.target.copy(target);
        if (orbit.enabled) orbit.update();
      }
      if (fp && fp.enabled){
        fp.lookAt(target);
        fp.update(0);
      }
    }

    // Enable pointer interactions on gizmo canvas
    gizmoRenderer.domElement.addEventListener('pointerdown', (e)=>{
      // Don't let this click interact with the main viewer
      e.preventDefault();
      e.stopPropagation();

      const rect = gizmoRenderer.domElement.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
      gizmoPointer.set(x, y);

      gizmoRaycaster.setFromCamera(gizmoPointer, gizmoCamera);
      const hits = gizmoRaycaster.intersectObjects(gizmoRoot.children, true);

      const hit = hits.find(h => h.object && h.object.userData && h.object.userData.__axis);
      if (!hit) return;

      const { dir } = hit.object.userData.__axis;
      if (dir) snapViewToAxis(dir);
    }, { passive:false });
    let updateOverlay = () => {};
    let clearAll = () => {};

    // --- FIX 1: Reduced near clip plane from 1 to 0.1 ---
    // This ensures geometry doesn't disappear before you hit it.
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 150000);
    camera.position.set(0,2,0);
    const clock = new THREE.Clock();

    const INITIAL_POS  = new THREE.Vector3(0, 2, 0);
    const INITIAL_LOOK = new THREE.Vector3(0, 2, 1);

    function setInitialView() {
      camera.position.copy(INITIAL_POS);
      camera.quaternion.set(0, 0, 0, 1);
      camera.up.set(0, 1, 0);
      camera.fov = 45;
      camera.updateProjectionMatrix();

      const orbit = window.__orbit__;
      const fp = window.__fp__;
      orbit.enabled = false;
      orbit.target.copy(INITIAL_LOOK);
      orbit.update();

      fp.enabled = true;
      fp.lookAt(INITIAL_LOOK);
      fp.update(0);
    }

    // Controls
    const fp = new FirstPersonControls(camera, renderer.domElement);
    const BASE_SPEED = 5;
    fp.enabled = true;
    fp.movementSpeed = BASE_SPEED;
    fp.lookAt(new THREE.Vector3(0,2,1));
    window.__fp__ = fp;

    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enabled = false;
    orbit.enableDamping = true; orbit.dampingFactor = 0.08;
    orbit.rotateSpeed = 0.85; orbit.zoomSpeed = 1.2; orbit.panSpeed = 0.8;
    orbit.enablePan = true; orbit.enableZoom = true;
    orbit.minDistance = 0.2; orbit.maxDistance = 5000;
    window.__orbit__ = orbit;

    setInitialView();

    
// Query string -> use ?id=FILE_ID (preferred) or fallback ?data=...&title=...
const params = new URLSearchParams(window.location.search);

const titleEl = document.getElementById("page-title");

// Preferred: only query id
const fileId = params.get("id");

// Fallback legacy params
let lccLink = params.get("data") || "";
let titleText = params.get("title") ? decodeURIComponent(params.get("title")) : "";

const API_BASE = params.get("api") || "https://3dr4vhc7-9000.asse.devtunnels.ms/lcc/lccData";
// Password verification endpoint (override via ?checkUrl=...)
const CHECK_PASSWORD_URL = params.get("checkUrl") || "https://3dr4vhc7-9000.asse.devtunnels.ms/lcc/lccData/checkPassword";
    let __BLOCK_LOAD__ = false;

function setTitleText(t){
  const v = (t || "").trim();
  if (v.length){
    titleEl.textContent = v;
    titleEl.style.display = "inline-block";
  } else {
    titleEl.style.display = "none";
  }
}

function deriveTitleFromLink(link){
  try{
    const u = new URL(link, window.location.origin);
    const seg = u.pathname.split("/").filter(Boolean);
    const idx = seg.indexOf("uploads");
    // Example: /uploads/company1/title1/<uuid>/data.bin  -> title1
    if (idx >= 0 && seg.length > idx + 2) return seg[idx + 2];
    // fallback last folder
    if (seg.length >= 2) return seg[seg.length - 2];
  }catch(_){}
  return "";
}

// Password modal helpers (client-side check, since backend currently returns password)
function showPasswordModal({ title = "Enter password", hint = "" } = {}){
  return new Promise((resolve)=>{
    const modal = document.getElementById("pwd-modal");
    const titleEl2 = document.getElementById("pwd-title");
    const hintEl = document.getElementById("pwd-hint");
    const input = document.getElementById("pwd-input");
    const err = document.getElementById("pwd-error");
    const okBtn = document.getElementById("pwd-ok");
    const cancelBtn = document.getElementById("pwd-cancel");

    if(!modal || !input || !okBtn || !cancelBtn){
      resolve(null);
      return;
    }

    titleEl2.textContent = title;
    hintEl.textContent = hint || "";
    err.textContent = "";
    input.value = "";

    const close = (val)=>{
      modal.classList.remove("open");
      modal.setAttribute("aria-hidden","true");
      okBtn.removeEventListener("click", onOk);
      cancelBtn.removeEventListener("click", onCancel);
      modal.removeEventListener("click", onBackdrop);
      input.removeEventListener("keydown", onKey);
      resolve(val);
    };

    const onOk = ()=> close(String(input.value || ""));
    const onCancel = ()=> close(null);
    const onBackdrop = (e)=>{ if(e.target === modal) onCancel(); };
    const onKey = (e)=>{
      if(e.key === "Enter"){ e.preventDefault(); onOk(); }
      if(e.key === "Escape"){ e.preventDefault(); onCancel(); }
    };

    okBtn.addEventListener("click", onOk);
    cancelBtn.addEventListener("click", onCancel);
    modal.addEventListener("click", onBackdrop);
    input.addEventListener("keydown", onKey);

    modal.classList.add("open");
    modal.setAttribute("aria-hidden","false");
    setTimeout(()=>input.focus(), 0);
  });
}

async function resolveFileMetaById(id){
  const url = `${API_BASE}/${id}`;
  const res = await fetch(url, { cache: "no-store" });
  if(!res.ok) throw new Error(`Failed to fetch file meta (${res.status})`);
  let data = await res.json();
  if (Array.isArray(data)) data = data[0];
  return data || null;
}

async function ensureUnlockedIfNeeded(meta, id){
  if(!meta || !meta.enablePassword) return true;

  // Remember unlock for this tab/session
  const key = `lcc_unlock_${id}`;
  if (sessionStorage.getItem(key) === "1") return true;

  const t = deriveTitleFromLink(meta.link || "") || meta.name || id || "file";

  async function verifyRemote(password){
    const payload = { 
      fileId: id, 
      password 
    };
    const res = await fetch(CHECK_PASSWORD_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    let json = null;
    try{ json = await res.json(); }catch(_){ json = null; }

    // Accept common success shapes
    const ok = !!(
      (res.ok && json === null) ||
      json === true ||
      json?.success === true ||
      json?.ok === true ||
      json?.valid === true ||
      json?.status === "success" ||
      json?.data === true ||
      json?.data?.valid === true
    );

    const message =
      json?.message ||
      json?.error ||
      (res.ok ? "" : `HTTP ${res.status}`);

    return { ok, message, raw: json, status: res.status };
  }

  // Keep asking until success or cancel
  for (let attempt = 0; attempt < 10; attempt++){
    const entered = await showPasswordModal({
      title: "Password required",
      hint: `This file is protected: ${t}`
    });
    if (entered === null) return false; // user cancelled

    const { ok, message } = await verifyRemote(String(entered || ""));
    if (ok){
      sessionStorage.setItem(key, "1");
      return true;
    }

    const err = document.getElementById("pwd-error");
    if (err) err.textContent = message || "Wrong password. Please try again.";
  }
  return false;
}

// Resolve file info
if (fileId){
  try{
    const meta = await resolveFileMetaById(fileId);
    console.log(meta);

    // link and title from backend record
    if (meta && meta.link) lccLink = meta.link;
    if (!titleText){
      titleText = meta?.title || deriveTitleFromLink(meta?.link || "") || meta?.name || fileId;
    }
    setTitleText(titleText);

    // Gate loading
    const ok = await ensureUnlockedIfNeeded(meta, fileId);
    if (!ok){
      // stop: do not load LCC
      console.warn("LCC loading blocked (password not provided).");
      // also close marking panel if open
      try{
        const annotPanel = document.getElementById("annot-panel");
        const markingPill = document.getElementById("marking-pill");
        annotPanel && annotPanel.classList.remove("open");
        markingPill && markingPill.classList.remove("open");
      }catch(_){}
      __BLOCK_LOAD__ = true;
          // keep UI but stop LCC loading
    }
  }catch(e){
    console.error(e);
    setTitleText(titleText || "Locked / Error");
    // show a simple overlay message
    const lockMsg = document.getElementById("lock-msg");
    if (lockMsg){
      lockMsg.style.display = "flex";
      lockMsg.querySelector(".lock-msg-text").textContent =
        (String(e?.message||"").includes("Blocked") ? "Password required to open this file." : "Failed to load file information.");
    }
    // prevent continuing to load
    __BLOCK_LOAD__ = true;
  }
} else {
  // legacy behavior: use ?data and ?title if present
  setTitleText(titleText);
}

// If no link resolved, block load
if (!lccLink){
  const lockMsg = document.getElementById("lock-msg");
  if (lockMsg){
    lockMsg.style.display = "flex";
    lockMsg.querySelector(".lock-msg-text").textContent = "Missing file";
  }
  __BLOCK_LOAD__ = true;
          // keep UI but stop LCC loading
}
// ==========================================
    // LCC LOAD & COLLISION SETUP
    // ==========================================
    let hasCollisionData = false;
    const modelMatrix = new THREE.Matrix4(-1,0,0,0, 0,0,1,0  , 0,1,0,0, 0,0,0,1);
    
    
function createNoopLccObj(){
  return {
    hasCollision: false,
    togglePointsDisplayMode: ()=>{},
    useEnvironment: ()=>{},
    raycastFromOrigin: ()=>null,
    intersectsSphere: ()=>false
  };
}

let lccObj = createNoopLccObj();
if (!__BLOCK_LOAD__){
  lccObj = LCCRender.load(
      { camera, scene, dataPath:lccLink,
        renderLib: THREE, canvas: renderer.domElement, renderer,
        useEnv:true, useIndexDB:true, useLoadingEffect:true, modelMatrix, appKey:null },
      (res) => {
        // Success callback: Check for collision capability
        if (lccObj.hasCollision && lccObj.hasCollision()) {
           hasCollisionData = true;
           console.log("LCC Collision data available.");
        } else {
           console.log("LCC Collision data NOT available.");
        }
      }, 
      ()=>{}, 
      ()=>{}
    );
    }

    const $ = id=>document.getElementById(id);

    $("btn-switch-mode").addEventListener("click",()=>lccObj.togglePointsDisplayMode());
    $("btn-locate").addEventListener("click",()=>{camera.position.set(0,2,0);fp.lookAt(new THREE.Vector3(0,2,1)); clearScanPath();});
    
    // ===== Help overlay bindings =====
    const helpEl = $("help");
    const helpClose = $("help-close");
    const helpModeFPS = $("helpMode-fps");
    const helpModePivot = $("helpMode-pivot");

    function reflectHelpMode(){
      const map = {fps:helpModeFPS, pivot:helpModePivot};
      [helpModeFPS,helpModePivot].forEach(b=>b.classList.remove("active"));
      (map[viewMode]||helpModeFPS).classList.add("active");
    }

    $("btn-help").addEventListener("click",()=>{
      reflectHelpMode();
      helpEl.classList.add("open"); helpEl.ariaHidden="false";
      if(viewMode === 'pivot'){
        document.querySelector('.help-controls').style.display = 'none';
        document.querySelector('.help-controls-2').style.display = 'flex';
      }else{
        document.querySelector('.help-controls').style.display = 'flex';
        document.querySelector('.help-controls-2').style.display = 'none';
      }
    });
    helpClose.addEventListener("click",()=>{helpEl.classList.remove("open"); helpEl.ariaHidden="true";});
    helpEl.addEventListener("click",e=>{ if(e.target.id==="help") helpClose.click(); });

    // ===== Existing UI layout scripts (measure, drawer, etc.) =====
    const subbar = $('measure-subbar');
    const btnMeasure = $('btn-measure');
    function positionSubbar(){
      const r = btnMeasure.getBoundingClientRect(), gap=8;
      subbar.style.left = `${Math.round(r.left)}px`;
      subbar.style.top  = `${Math.round(r.bottom + gap)}px`;
    }

    const btnOptions = $('btn-options');
    const drawer = $('drawer-options');
    function positionDrawerUnderButton(){
      const r = btnOptions.getBoundingClientRect();
      const gap = 8;
      const panelW = drawer.offsetWidth || 360;
      const left = 10;
      const top  = Math.round(r.bottom + gap);
      drawer.style.left = `${left}px`;
      drawer.style.top  = `${top}px`;
      const caret = Math.min(panelW-30, Math.max(20, r.left - left + r.width/2));
      drawer.style.setProperty("--caret-left", `${caret}px`);
    }
    const dynStyle = document.createElement('style');
    dynStyle.textContent = `.drawer::before{left:var(--caret-left,20px);}`;
    document.head.appendChild(dynStyle);

    btnOptions.addEventListener('click', (e)=>{
      e.stopPropagation();
      const open = !drawer.classList.contains('open');
      if(open){ drawer.classList.add('open'); btnOptions.classList.add('active'); positionDrawerUnderButton(); }
      else { drawer.classList.remove('open'); btnOptions.classList.remove('active'); }
    });
    document.addEventListener('click',(e)=>{
      if (!drawer.classList.contains('open')) return;
      const inside = e.target.closest('#drawer-options, #btn-options');
      if(!inside){ drawer.classList.remove('open'); btnOptions.classList.remove('active'); }
    });

    document.querySelector('#main-menu').addEventListener('click', ()=>{
      document.querySelector('#main-toolbar').classList.toggle('open');
    });

    const envSeg = $('env-seg');
    function applyEnv(choice){ lccObj.useEnvironment(choice!=='none'); }
    envSeg.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-v]'); if(!btn || btn.disabled) return;
      envSeg.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active'); applyEnv(btn.dataset.v);
    });
    applyEnv('env');

    const renderSlider = $('render-slider');
    function applyDPRFromSlider(){
      const dpr = window.devicePixelRatio || 1;
      const factors = [0.5, 0.8, 1.0, 1.5, 2.0];
      const pxr = Math.min(dpr * (factors[+renderSlider.value] ?? 0.5), 3.0);
      renderer.setPixelRatio(pxr);
      renderer.setSize(window.innerWidth, window.innerHeight, false);
      updateOverlay();
    }
    renderSlider.addEventListener('input', applyDPRFromSlider);

    window.addEventListener('resize', ()=>{
      const uiRoot = document.getElementById('ui-root');
      uiRoot.style.transform = `scale(${1 / window.devicePixelRatio})`;
      uiRoot.style.transformOrigin = "top left";
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      positionSubbar();
      applyDPRFromSlider();
      if(drawer.classList.contains('open')) positionDrawerUnderButton();
      updateOverlay();
      if(pivotWorld) pivotScreen = worldToScreen(pivotWorld.x, pivotWorld.y, pivotWorld.z);
      setGizmoSize(GIZMO_SIZE);
    });
    positionSubbar();
    applyDPRFromSlider();

    /* =========================
       Measurement
    ==========================*/
    const segRoot = $('segments-root');
    const areaRoot = $('areas-root');
    const previewLine = $('preview-line');
    const previewPoly = $('preview-poly');
    const previewAreaFill = $('preview-area-fill');
    const labelsLayer = $('labels-layer');
    const loupe = $('loupe');
    const loupeCanvas = $('loupeCanvas');
    // Stable backing resolution for crisp zoom
    loupeCanvas.width = 256;
    loupeCanvas.height = 256;
    const loupeCtx = loupeCanvas.getContext('2d');

    let suppressOverlays = false;
    function hideCrosshair(){ const ch = document.querySelector('#crosshair'); if(ch) ch.style.display='none'; }
    function setSuppressOverlays(v){
      suppressOverlays = !!v;
      if (suppressOverlays){
        loupe.style.display = 'none';
        hideCrosshair();
      }
    }
    function bindHoverHide(selectorList){
      document.querySelectorAll(selectorList).forEach(el=>{
        el.addEventListener('mouseenter', ()=> measuring && setSuppressOverlays(true));
        el.addEventListener('mouseleave', ()=> measuring && setSuppressOverlays(false));
      });
    }
    bindHoverHide('#main-toolbar, #main-menu, #drawer-options, #measure-subbar, #persp-bubble');

    const crosshair = document.querySelector('#crosshair');
    const showCrosshair=(x,y)=>{
      // Loupe mode: use the native cursor (crosshair) instead of the large SVG target.
      // Keep the SVG crosshair hidden to match the zoom-loupe UX.
      hideCrosshair();
    }

    let measuring=false, mode='distance';
    const modeDist = $('mode-distance');
    const modeArea = $('mode-area');

    let hideHistory = false;
    const swHideHistory = $('sw-hide-history');
    const toggleSwitch = (el, on)=>{
      el.classList.toggle('on', !!on);
      el.querySelector('input').checked = !!on;
    };
    swHideHistory.addEventListener('click',()=>{
      const willBeOn = !swHideHistory.classList.contains('on');
      hideHistory = willBeOn;
      toggleSwitch(swHideHistory, willBeOn);
      updateOverlay();
    });

    function setMeasMode(m){
      mode=m;
      modeDist.classList.toggle('active', m==='distance');
      modeArea.classList.toggle('active', m==='area');
      previewLine.__show=false; previewLine.style.display='none';
      previewPoly.__show=false; previewPoly.style.display='none';
      if(previewAreaFill) previewAreaFill.style.display='none';
    }
    modeDist.addEventListener('click',()=>setMeasMode('distance'));
    modeArea.addEventListener('click',()=>setMeasMode('area'));

    $('btn-measure').addEventListener('click', (e)=>{
      measuring = !measuring;
      e.currentTarget.classList.toggle('active', measuring);
      subbar.classList.toggle('open', measuring);
      positionSubbar();

      // Zoom-cursor loupe mode: use native crosshair cursor
      renderer.domElement.style.cursor = measuring ? 'crosshair' : '';

      loupe.style.display = measuring && !suppressOverlays ? 'block' : 'none';
      if(measuring){
        hideCrosshair(); // keep the large SVG target hidden
      }else{
        clearAll();
        hideCrosshair();
        setSuppressOverlays(false);
      }
    });

    const segSystem = $('seg-system');
    const segDistance = $('seg-distance');
    let unitSystem='metric', distanceUnit='m';

    function fmtDist(m){
      if(unitSystem==='metric'){
        if(distanceUnit==='cm') return (m*100).toFixed(0)+' cm';
        return m.toFixed(2)+' m';
      }else{
        if(distanceUnit==='in') return (m*39.37007874).toFixed(1)+' in';
        return (m*3.280839895).toFixed(2)+' ft';
      }
    }
    function fmtAxis(m, axis){
      const abs=Math.abs(m);
      let txt;
      if(unitSystem==='metric'){
        txt = distanceUnit==='cm' ? (m*100).toFixed(abs<1?1:0)+' cm' : m.toFixed(abs<1?3:2)+' m';
      }else{
        txt = (distanceUnit==='in' ? (m*39.37007874).toFixed(abs<1?1:0)+' in'
                                   : (m*3.280839895).toFixed(abs<1?3:2)+' ft');
      }
      return `${axis}: ${txt}`;
    }
    function fmtArea(m2){
      if(unitSystem==='metric'){
        if(distanceUnit==='cm'){ const cm2=m2*10000; return `${cm2.toFixed(2)} cm²`; }
        return `${m2.toFixed(2)} m²`;
      }else{
        if(distanceUnit==='in'){ const in2=m2*1550.0031; return `${in2.toFixed(2)} in²`; }
        const ft2=m2*10.7639104167; return `${ft2.toFixed(2)} ft²`;
      }
    }
    function updateDistanceSeg(){
      const [b1,b2] = segDistance.querySelectorAll('button');
      if(unitSystem==='metric'){ b1.textContent='Meters'; b1.dataset.unit='m'; b2.textContent='Centimeters'; b2.dataset.unit='cm'; }
      else { b1.textContent='Feet'; b1.dataset.unit='ft'; b2.textContent='Inches'; b2.dataset.unit='in'; }
    }
    segSystem.addEventListener('click',e=>{
      const btn=e.target.closest('button[data-sys]'); if(!btn) return;
      segSystem.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active'); unitSystem=btn.dataset.sys; updateDistanceSeg(); updateOverlay();
    });
    segDistance.addEventListener('click',e=>{
      const btn=e.target.closest('button[data-unit]'); if(!btn) return;
      segDistance.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active'); distanceUnit=btn.dataset.unit; updateOverlay();
    });

    let chain=[], segments=[], polyPts=[], areas=[];
    let proMode=false;
    const swScan = $('sw-scan'), scanCheckbox = $('opt-scan');
    const swPro = $('sw-pro');
    const setSwitch=(el,on)=>{ el.classList.toggle('on',!!on); el.querySelector('input').checked=!!on; };
    swScan.addEventListener('click',()=>{ setSwitch(swScan, !swScan.classList.contains('on')); scanCheckbox.checked = swScan.classList.contains('on'); setScanVisible(scanCheckbox.checked); });
    swPro.addEventListener('click',()=>{ setSwitch(swPro, !swPro.classList.contains('on')); proMode = swPro.classList.contains('on'); updateOverlay(); });

    function makeLabel(mode = "distance"){
      const label = document.createElement('div');
      label.className=`${mode ==="area" ? "measure-label-area" : "measure-label"}`;
      label.innerHTML = `<span class="meta"></span><button class="lbl-del" title="Delete">Delete</button>`;
      labelsLayer.appendChild(label);
      return label;
    }

    function addSeg(a,b,root=segRoot,isAreaLine=false){
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('stroke','white'); line.setAttribute('stroke-width','2');
      line.setAttribute('stroke-dasharray','6 6');
      line.setAttribute('marker-start','url(#arrow)'); line.setAttribute('marker-end','url(#arrow)');
      root.appendChild(line);

      const leader = document.createElementNS('http://www.w3.org/2000/svg','line');
      leader.setAttribute('class','leader'); leader.style.display='none';
      root.appendChild(leader);

      const label = makeLabel(isAreaLine ? "area" : "distance");
      return {a:{...a}, b:{...b}, line, label, leader};
    }

    function computePlaneBasis(pts){
      const p0=new THREE.Vector3(pts[0].x,pts[0].y,pts[0].z);
      const p1=new THREE.Vector3(pts[1].x,pts[1].y,pts[1].z);
      const p2=new THREE.Vector3(pts[2].x,pts[2].y,pts[2].z);
      const u=new THREE.Vector3().subVectors(p1,p0).normalize();
      const n=new THREE.Vector3().subVectors(p2,p0).cross(u).normalize();
      const v=new THREE.Vector3().crossVectors(n,u).normalize();
      return {origin:p0,u,v};
    }
    const project2D=(pts,b)=>pts.map(p=>{const v=new THREE.Vector3(p.x,p.y,p.z).sub(b.origin);return {x:v.dot(b.u),y:v.dot(b.v)};});
    const area2D=(pts)=>Math.abs(pts.reduce((A,p,i)=>{const j=(i+1)%pts.length;return A + p.x*pts[j].y - pts[j].x*pts[i].y;},0))*0.5;
    const centroid3=(pts)=>{const c=pts.reduce((s,p)=>({x:s.x+p.x,y:s.y+p.y,z:s.z+p.z}),{x:0,y:0,z:0});return {x:c.x/pts.length,y:c.y/pts.length,z:c.z/pts.length};};

    // ---- Area measurement constraints (no crossing) ----
    // In "Area" mode, prevent drawing polygon edges that cross existing edges
    // (both in-progress polygon edges and existing measurement history).
    function _pt2d(p){
      const s = worldToScreen(p.x, p.y, p.z);
      return s ? { x: s.x, y: s.y } : null;
    }
    function _near2(a,b,eps=1.5){ return Math.hypot(a.x-b.x, a.y-b.y) <= eps; }
    function _orient(a,b,c){ return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x); }
    function _onSeg(a,b,c,eps=1e-9){
      return Math.min(a.x,b.x)-eps <= c.x && c.x <= Math.max(a.x,b.x)+eps &&
             Math.min(a.y,b.y)-eps <= c.y && c.y <= Math.max(a.y,b.y)+eps &&
             Math.abs(_orient(a,b,c)) <= eps;
    }
    function _segIntersect(a,b,c,d){
      // Allow touching exactly at shared endpoints (typical polygon joints)
      if(_near2(a,c) || _near2(a,d) || _near2(b,c) || _near2(b,d)) return false;

      const o1=_orient(a,b,c), o2=_orient(a,b,d), o3=_orient(c,d,a), o4=_orient(c,d,b);
      const eps=1e-9;

      // Proper intersection
      if(((o1>eps && o2<-eps) || (o1<-eps && o2>eps)) && ((o3>eps && o4<-eps) || (o3<-eps && o4>eps))) return true;

      // Colinear / touching (counts as crossing for our tool)
      if(Math.abs(o1)<=eps && _onSeg(a,b,c)) return true;
      if(Math.abs(o2)<=eps && _onSeg(a,b,d)) return true;
      if(Math.abs(o3)<=eps && _onSeg(c,d,a)) return true;
      if(Math.abs(o4)<=eps && _onSeg(c,d,b)) return true;

      return false;
    }

    function _edgeCrossesHistory(a3,b3){
      const a=_pt2d(a3), b=_pt2d(b3);
      if(!a || !b) return false;

      for(const s of segments){
        const c=_pt2d(s.a), d=_pt2d(s.b);
        if(c && d && _segIntersect(a,b,c,d)) return true;
      }
      for(const ar of areas){
        for(const ed of ar.edges){
          const c=_pt2d(ed.a), d=_pt2d(ed.b);
          if(c && d && _segIntersect(a,b,c,d)) return true;
        }
      }
      return false;
    }

    function _edgeCrossesPoly(a3,b3){
      if(polyPts.length < 2) return false;
      const a=_pt2d(a3), b=_pt2d(b3);
      if(!a || !b) return false;

      // Check against existing edges of the in-progress polygon: (p0-p1, p1-p2, ...)
      for(let i=1;i<polyPts.length;i++){
        const c=_pt2d(polyPts[i-1]), d=_pt2d(polyPts[i]);
        if(!c || !d) continue;
        if(_segIntersect(a,b,c,d)) return true;
      }
      return false;
    }

    function canAddAreaPoint(nextPt){
      if(polyPts.length === 0) return true;
      const prev = polyPts[polyPts.length - 1];

      // New edge (prev -> next) must not cross any existing edge.
      if(_edgeCrossesPoly(prev, nextPt)) return false;
      if(_edgeCrossesHistory(prev, nextPt)) return false;
      return true;
    }

    function canCloseAreaPolygon(){
      if(polyPts.length < 3) return false;
      const first = polyPts[0];
      const last  = polyPts[polyPts.length - 1];

      // Closing edge (last -> first) must not cross existing edges.
      if(_edgeCrossesPoly(last, first)) return false;
      if(_edgeCrossesHistory(last, first)) return false;
      return true;
    }


    function addArea(pts){
      const path=document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('fill','rgba(96,165,250,0.35)');
      path.setAttribute('stroke','white'); path.setAttribute('stroke-width','2');
      areaRoot.appendChild(path);

      const labelArea = makeLabel();

      const edges=[];
      for(let i=0;i<pts.length;i++){
        const a=pts[i]; const b=pts[(i+1)%pts.length];
        edges.push(addSeg(a,b,areaRoot,true));
      }
      const aObj={pts:pts.map(p=>({...p})), path, labelArea, edges, centroid:centroid3(pts)};
      areas.push(aObj);
    }

    labelsLayer.addEventListener('click', (e)=>{
      const btn = e.target.closest('.lbl-del'); if(!btn) return;
      // While actively drawing a measurement, prevent deleting other lines/areas.
      if(measuring && (chain.length>0 || polyPts.length>0)) return;
      const label = btn.closest('.measure-label, .measure-label-area');
      const segIdx = segments.findIndex(s=>s.label===label);
      if(segIdx>=0){
        const s=segments.splice(segIdx,1)[0];
        s.line.remove(); s.label.remove(); s.leader.remove();
        return;
      }
      const areaIdx = areas.findIndex(a=>a.labelArea===label);
      if(areaIdx>=0){
        const a=areas.splice(areaIdx,1)[0];
        a.path.remove(); a.labelArea.remove();
        a.edges.forEach(e2=>{e2.line.remove(); e2.label.remove(); e2.leader.remove();});
      }
    });

        // --- Loupe (zoom cursor) ---
    // Position loupe above/below the mouse (mouse is NOT the loupe center),
    // and sample pixels from the WebGL framebuffer via readPixels.
    const loupeScratch = document.createElement('canvas');
    const LOUPE_SRC = 24; // sample size in canvas pixels (smaller = stronger zoom)
    loupeScratch.width = LOUPE_SRC;
    loupeScratch.height = LOUPE_SRC;
    const loupeScratchCtx = loupeScratch.getContext('2d');
    let loupePixels = new Uint8Array(LOUPE_SRC * LOUPE_SRC * 4);

    const loupeState = { clientX: 0, clientY: 0, cx: 0, cy: 0, valid: false };

    function positionLoupe(clientX, clientY){
      // Loupe is NOT inside the DPR-scaled #ui-root, so we position in CSS pixels.
      const w = loupe.offsetWidth;
      const h = loupe.offsetHeight;
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      const gap = 25;

      // Default: show BELOW the mouse (so the mouse is not centered in the loupe)
      let left = clientX - w / 2;
      let top  = clientY + gap;

      // If we would go off-screen at the bottom, flip ABOVE the mouse
      if (top + h > vh - gap) top = clientY - h - gap;

      // Edge behavior like the reference image:
      // - keep the loupe "attached" to the mouse even near the left edge
      // - allow it to go partially off-screen (instead of forcing it fully inside)
      const visible = 28; // keep at least this many pixels visible
      left = Math.max(-w + visible, Math.min(left, vw - visible));

      // Keep vertical fully visible (and still allow the flip-above behavior)
      top  = Math.max(gap, Math.min(top,  vh - h - gap));

      loupe.style.left = `${Math.round(left)}px`;
      loupe.style.top  = `${Math.round(top)}px`;
    }

    function updateLoupeAt(x,y){
      if(!measuring || suppressOverlays){
        loupe.style.display = 'none';
        loupeState.valid = false;
        return;
      }

      loupe.style.display='block';
      positionLoupe(x, y);

      // Convert client coords -> canvas pixel coords
      const rect = renderer.domElement.getBoundingClientRect();
      const nx = (x - rect.left) / rect.width;
      const ny = (y - rect.top)  / rect.height;

      if (nx < 0 || nx > 1 || ny < 0 || ny > 1){
        loupeState.valid = false;
        return;
      }

      loupeState.clientX = x;
      loupeState.clientY = y;
      loupeState.cx = Math.round(nx * renderer.domElement.width);
      loupeState.cy = Math.round(ny * renderer.domElement.height);
      loupeState.valid = true;
    }

    function renderLoupeSample(){
      if(!measuring || suppressOverlays || !loupeState.valid) return;

      const canvas = renderer.domElement;
      const gl = renderer.getContext ? renderer.getContext() : null;
      if(!gl) return;

      const src = LOUPE_SRC;
      const half = Math.floor(src / 2);

      const w = canvas.width;
      const h = canvas.height;

      // Desired top-left origin coords (centered at the mouse; may go out of bounds)
      const x0 = loupeState.cx - half;
      const y0 = loupeState.cy - half;

      // Compute in-bounds read rect + where it lands inside the scratch buffer
      let dx = 0, dy = 0;
      let rx = x0, ry = y0;

      if (rx < 0){ dx = -rx; rx = 0; }
      if (ry < 0){ dy = -ry; ry = 0; }

      let vw = src - dx;
      let vh = src - dy;

      if (rx + vw > w) vw = w - rx;
      if (ry + vh > h) vh = h - ry;

      if (vw <= 0 || vh <= 0) return;

      // Convert to GL coords (origin bottom-left)
      const rygl = h - (ry + vh);

      // Ensure scratch matches src
      if (loupeScratch.width !== src){
        loupeScratch.width = src;
        loupeScratch.height = src;
        loupePixels = new Uint8Array(src * src * 4);
      }

      // Read only the valid part of the framebuffer
      const needed = vw * vh * 4;
      const readBuf = (loupePixels.length >= needed) ? loupePixels.subarray(0, needed) : new Uint8Array(needed);

      try{
        gl.readPixels(rx, rygl, vw, vh, gl.RGBA, gl.UNSIGNED_BYTE, readBuf);
      }catch(e){
        return;
      }

      // Compose a full src×src ImageData, placing the read region at (dx,dy),
      // and flipping vertically (GL is bottom-left origin).
      const img = loupeScratchCtx.createImageData(src, src);
      const dst = img.data;
      const rowBytes = vw * 4;

      for(let y=0; y<vh; y++){
        const srcRow = (vh - 1 - y);
        const srcOff = srcRow * rowBytes;
        const dstOff = ((dy + y) * src + dx) * 4;
        dst.set(readBuf.subarray(srcOff, srcOff + rowBytes), dstOff);
      }

      loupeScratchCtx.putImageData(img, 0, 0);


// Draw magnified sample
      loupeCtx.clearRect(0, 0, loupeCanvas.width, loupeCanvas.height);
      loupeCtx.imageSmoothingEnabled = false;
      loupeCtx.drawImage(
        loupeScratch,
        0, 0, src, src,
        0, 0, loupeCanvas.width, loupeCanvas.height
      );

      // Reticle overlay (like the reference image)
      const cx = loupeCanvas.width / 2;
      const cy = loupeCanvas.height / 2;
      loupeCtx.save();
      loupeCtx.strokeStyle = 'rgba(255,255,255,0.95)';
      loupeCtx.lineWidth = 2;
      loupeCtx.beginPath();
      loupeCtx.moveTo(0, cy); loupeCtx.lineTo(loupeCanvas.width, cy);
      loupeCtx.moveTo(cx, 0); loupeCtx.lineTo(cx, loupeCanvas.height);
      loupeCtx.stroke();
      loupeCtx.fillStyle = 'rgba(255,255,255,0.95)';
      loupeCtx.beginPath();
      loupeCtx.arc(cx, cy, 4, 0, Math.PI * 2);
      loupeCtx.fill();
      loupeCtx.restore();
    }

    function hidePreview(){ previewLine.__show=false; previewLine.style.display='none'; previewPoly.__show=false; previewPoly.style.display='none'; if(previewAreaFill) previewAreaFill.style.display='none'; }

    /* =========================
       Perspective modes
    ==========================*/
    const btnPerspective = $('btn-perspective');
    const perspBubble = $('persp-bubble');
    const btnFPS   = $('mode-fps');
    const btnPivot = $('mode-pivot');
    const tip = $('persp-tip');

    let viewMode = 'fps'; // 'fps' | 'pivot'
    let pivotWorld = null;
    let pivotScreen = null;

    function setViewMode(mode){
      viewMode = mode;
      btnFPS.classList.toggle('active', mode==='fps');
      btnPivot.classList.toggle('active', mode==='pivot');
      tip.textContent = mode==='pivot' ? 'Pivot Mode' : 'First-person';
      reflectHelpMode();

      if(mode==='fps'){
        orbit.enabled = false; fp.enabled = true;
        document.querySelector('#fps-icon').style.display = 'inline-flex';
        document.querySelector('#pivot-icon').style.display = 'none';
      } else {
        fp.enabled = false; orbit.enabled = true;
        document.querySelector('#fps-icon').style.display = 'none';
        document.querySelector('#pivot-icon').style.display = 'inline-flex';
      }
    }

    btnPerspective.addEventListener('click', (e)=>{
      e.stopPropagation();
      perspBubble.classList.toggle('open');
    });
    document.addEventListener('click', (e)=>{
      if(!perspBubble.classList.contains('open')) return;
      const inside = e.target.closest('#persp-bubble, #btn-perspective');
      if(!inside) perspBubble.classList.remove('open');
    });

    btnFPS.addEventListener('click', ()=>{ setViewMode('fps'); });
    btnPivot.addEventListener('click', ()=>{ setViewMode('pivot'); });

    function resetCamera(){
      camera.position.set(0,2,0);
      camera.lookAt(0,2,1);
      orbit.target.set(0,2,1);
      pivotWorld = null; pivotScreen = null;
      setViewMode('fps');
      updateOverlay();
    }

    /* =========================
       Picking
    ==========================*/
    const maxDistance=300; let rayRadius=0.05;
    const thePickRay = new THREE.Vector3();
    function pick(clientX,clientY){
      const ndcX=(clientX/window.innerWidth)*2-1, ndcY=-(clientY/window.innerHeight)*2+1;
      thePickRay.set(ndcX, ndcY, 0.5).unproject(camera).sub(camera.position).normalize();
      const origin = {x:camera.position.x,y:camera.position.y,z:camera.position.z};
      const direction = {x:thePickRay.x,y:thePickRay.y,z:thePickRay.z};
      return lccObj.raycastFromOrigin({origin,direction,maxDistance,radius:rayRadius})||null;
    }
    function worldToScreen(x,y,z){
      const v=new THREE.Vector3(x,y,z).project(camera);
      if(!Number.isFinite(v.x)||!Number.isFinite(v.y)||v.z<-1||v.z>1) return null;
      return {x:(v.x+1)*0.5*window.innerWidth,y:(1-(v.y+1)*0.5)*window.innerHeight};
    }

    let suppressClickUntil = 0;
    const SUP_MS = 220;
    const markNav=()=>{suppressClickUntil=performance.now()+SUP_MS;}
    let downPos=null;
    let camOnDown = new THREE.Matrix4();
    let rightDownPos=null;
    let camOnRightDown = new THREE.Matrix4();
    let rightClickWasDrag=false;

    /* =========================
       FPS Panning Logic
    ==========================*/
    const fpsPan = { active: false, x: 0, y: 0 };

    renderer.domElement.addEventListener('mousedown', e=>{
      if(e.button === 2){ rightDownPos = {x:e.clientX,y:e.clientY}; camOnRightDown.copy(camera.matrixWorld); rightClickWasDrag=false; }
      if (viewMode === 'fps' && e.button === 2) { 
        fpsPan.active = true;
        fpsPan.x = e.clientX;
        fpsPan.y = e.clientY;
        fp.enabled = false; 
      }
      if(e.button!==0) return;
      downPos={x:e.clientX,y:e.clientY}; camOnDown.copy(camera.matrixWorld);
    });

    renderer.domElement.addEventListener('mouseup', e=>{
      if(e.button === 2 && rightDownPos){
        const driftR = Math.hypot(e.clientX-rightDownPos.x, e.clientY-rightDownPos.y);
        if(driftR>4) rightClickWasDrag=true;
        const camChangedR = camOnRightDown.elements.some((v,i)=>Math.abs(v - camera.matrixWorld.elements[i])>1e-5);
        if(camChangedR) rightClickWasDrag=true;
      }
      if (viewMode === 'fps' && fpsPan.active) {
        fpsPan.active = false;
        fp.enabled = true; 
      }

      if(e.button!==0) return;
      const now=performance.now();
      const drift=downPos?Math.hypot(e.clientX-downPos.x,e.clientY-downPos.y):1e9;
      const camChanged = camOnDown.elements.some((v,i)=>Math.abs(v - camera.matrixWorld.elements[i])>1e-5);
      const valid = downPos && drift<4 && !camChanged && now>suppressClickUntil;
      downPos=null; if(!valid) return;

      const hit = pick(e.clientX,e.clientY) || (()=>{const old=rayRadius; rayRadius=Math.min(0.25,old*2); const p2=pick(e.clientX,e.clientY); rayRadius=old; return p2;})()
      ;
      if(!hit) return;

      if(measuring){
        if(mode==='distance'){
          chain.push(hit);
          const n=chain.length;
          if(n>=2){ segments.push(addSeg(chain[n-2], chain[n-1])); updateOverlay(); }
        }else{
          if(!canAddAreaPoint(hit)) return;
          polyPts.push(hit);
          previewPoly.__pts=[...polyPts];
          previewPoly.__show=true;
        }
        return;
      }

      if(viewMode==='pivot'){
        const pivot = new THREE.Vector3(hit.x,hit.y,hit.z);
        orbit.target.set(pivot.x, pivot.y, pivot.z);
        updateOverlay();
      }
    });

    renderer.domElement.addEventListener('contextmenu', e=>{
      e.preventDefault(); 
      if(!measuring) return; 
      if(fpsPan.active) return; 

      // If the right button was used to pan/drag the camera, do NOT cancel or finish the current drawing.
      if(rightClickWasDrag){
        rightClickWasDrag = false;
        rightDownPos = null;
        return;
      }

      if(mode==='distance'){ chain.length=0; hidePreview(); }
      else {
        if(polyPts.length>=3){
          if(canCloseAreaPolygon()) addArea(polyPts);
        }
        polyPts.length=0; hidePreview();
      }
      rightDownPos = null;
      rightClickWasDrag = false;
    });

    updateOverlay = function(){
      camera.updateMatrixWorld(true);
      for(const s of segments){
        const sa=worldToScreen(s.a.x,s.a.y,s.a.z);
        const sb=worldToScreen(s.b.x,s.b.y,s.b.z);
        const forceHide = hideHistory;
        if(sa&&sb && !forceHide){
          s.line.setAttribute('x1',sa.x); s.line.setAttribute('y1',sa.y);
          s.line.setAttribute('x2',sb.x); s.line.setAttribute('y2',sb.y);
          s.line.style.display='';
          const midX=(sa.x+sb.x)/2, midY=(sa.y+sb.y)/2;
          const dx=s.b.x-s.a.x, dy=s.b.y-s.a.y, dz=s.b.z-s.a.z;
          const len = Math.hypot(dx,dy,dz);
          const meta = s.label.querySelector('.meta');
          if(proMode){
            s.label.classList.add('pro-card');
            meta.innerHTML = `<div class="pro-title">${fmtDist(len)}</div>
              <div class="pro-row">${fmtAxis(Math.abs(dx),'dx')}</div>
              <div class="pro-row">${fmtAxis(Math.abs(dy),'dy')}</div>
              <div class="pro-row">${fmtAxis(Math.abs(dz),'dz')}</div>`;
            const yOff=-70;
            Object.assign(s.label.style,{left:`${midX}px`,top:`${midY + yOff}px`,display:'block',transform:'translate(-50%,-10%)'});
            s.leader.setAttribute('x1',midX); s.leader.setAttribute('y1',midY-6);
            s.leader.setAttribute('x2',midX); s.leader.setAttribute('y2',midY + yOff + 20);
            s.leader.style.display='';
          }else{
            s.label.classList.remove('pro-card');
            meta.textContent = fmtDist(len);
            Object.assign(s.label.style,{left:`${midX}px`,top:`${midY}px`,display:'block',transform:'translate(-50%,-120%)'});
            s.leader.style.display='none';
          }
        }else{
          s.line.style.display='none'; s.label.style.display='none'; s.leader.style.display='none';
        }
      }

      for(const a of areas){
        const forceHide = hideHistory;
        if(forceHide){
          a.path.style.display='none';
          a.labelArea.style.display='none';
          for(const e of a.edges){
            e.line.style.display='none'; e.label.style.display='none'; e.leader.style.display='none';
          }
          continue;
        }
        const scr=a.pts.map(p=>worldToScreen(p.x,p.y,p.z));
        if(scr.some(p=>!p)){ a.path.style.display='none'; a.labelArea.style.display='none'; continue; }
        let d=`M ${scr[0].x} ${scr[0].y}`; for(let i=1;i<scr.length;i++) d+=` L ${scr[i].x} ${scr[i].y}`;
        a.path.setAttribute('d', d+' Z'); a.path.style.display='';
        const basis=computePlaneBasis(a.pts); const flat=project2D(a.pts,basis);
        const m2=area2D(flat); const c=worldToScreen(a.centroid.x,a.centroid.y,a.centroid.z);
        const meta = a.labelArea.querySelector('.meta');
        meta.textContent = fmtArea(m2);
        Object.assign(a.labelArea.style,{left:`${c.x}px`,top:`${c.y}px`,display:'block'});
        for(const e of a.edges){
          const sa2=worldToScreen(e.a.x,e.a.y,e.a.z);
          const sb2=worldToScreen(e.b.x,e.b.y,e.b.z);
          if(sa2&&sb2){
            e.line.setAttribute('x1',sa2.x); e.line.setAttribute('y1',sa2.y);
            e.line.setAttribute('x2',sb2.x); e.line.setAttribute('y2',sb2.y);
            e.line.style.display='';
            const midX=(sa2.x+sb2.x)/2, midY=(sa2.y+sb2.y)/2;
            const dx=e.b.x-e.a.x, dy=e.b.y-e.a.y, dz=e.b.z-e.a.z;
            const len = Math.hypot(dx,dy,dz);
            const metaE = e.label.querySelector('.meta');
            if(proMode){
              e.label.classList.add('pro-card');
              metaE.innerHTML = `<div class="pro-title">${fmtDist(len)}</div>
                <div class="pro-row">${fmtAxis(Math.abs(dx),'dx')}</div>
                <div class="pro-row">${fmtAxis(Math.abs(dy),'dy')}</div>
                <div class="pro-row">${fmtAxis(Math.abs(dz),'dz')}</div>`;
              const yOff=-70;
              Object.assign(e.label.style,{left:`${midX}px`,top:`${midY + yOff}px`,display:'block',transform:'translate(-50%,-10%)'});
              e.leader.setAttribute('x1',midX); e.leader.setAttribute('y1',midY-6);
              e.leader.setAttribute('x2',midX); e.leader.setAttribute('y2',midY + yOff + 20);
              e.leader.style.display='';
            }else{
              e.label.classList.remove('pro-card');
              metaE.textContent = fmtDist(len);
              Object.assign(e.label.style,{left:`${midX}px`,top:`${midY}px`,display:'block',transform:'translate(-50%,-120%)'});
              e.leader.style.display='none';
            }
          }else{
            e.line.style.display='none'; e.label.style.display='none'; e.leader.style.display='none';
          }
        }
      }

      if(previewLine.__show){
        const a=worldToScreen(previewLine.__a.x,previewLine.__a.y,previewLine.__a.z);
        const b=worldToScreen(previewLine.__b.x,previewLine.__b.y,previewLine.__b.z);
        if(a&&b){ previewLine.setAttribute('x1',a.x); previewLine.setAttribute('y1',a.y);
                  previewLine.setAttribute('x2',b.x); previewLine.setAttribute('y2',b.y);
                  previewLine.style.display=''; } else previewLine.style.display='none';
      }
      if(previewPoly.__show){
        const scr = previewPoly.__pts.map(p=>worldToScreen(p.x,p.y,p.z));
        if(scr.some(p=>!p)){
          previewPoly.style.display='none';
          if(previewAreaFill) previewAreaFill.style.display='none';
        }else{
          const ptsStr = scr.map(p=>`${p.x},${p.y}`).join(' ');
          previewPoly.setAttribute('points', ptsStr);
          previewPoly.style.display='';
          if(previewAreaFill){
            if(scr.length >= 3){
              previewAreaFill.setAttribute('points', ptsStr);
              previewAreaFill.style.display='';
            }else{
              previewAreaFill.style.display='none';
            }
          }
        }
      }else{
        if(previewAreaFill) previewAreaFill.style.display='none';
      }
    };

    clearAll = function(){
      segments.forEach(s=>{ s.line.remove(); s.label.remove(); s.leader.remove(); });
      areas.forEach(a=>{ a.path.remove(); a.labelArea.remove(); a.edges.forEach(e=>{e.line.remove();e.label.remove();e.leader.remove();}); });
      segments.length=0; areas.length=0; chain.length=0; polyPts.length=0;
      hidePreview();
    };

    const navKeys = new Set(['w','a','s','d','q','e','arrowup','arrowdown','arrowleft','arrowright',' ','shift']);
    const pressed = new Set();
    window.addEventListener('keydown',e=>{
      const k=e.key.toLowerCase();
      if(navKeys.has(k)) pressed.add(k);
      fp.movementSpeed = pressed.has('shift') ? BASE_SPEED*3 : BASE_SPEED;
    });
    window.addEventListener('keyup',e=>{
      pressed.delete(e.key.toLowerCase());
      fp.movementSpeed = pressed.has('shift') ? BASE_SPEED*3 : BASE_SPEED;
    });

    renderer.domElement.addEventListener(
      'wheel',
      (e) => {
        e.preventDefault();
        if (orbit.enabled) return;
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        const sign = e.deltaY < 0 ? 1 : -1;
        const speedMultiplier = pressed.has('shift') ? 0.35 : 0.25;
        const STEP = fp.movementSpeed * 0.25 * speedMultiplier;
        camera.position.addScaledVector(dir, sign * STEP);
        if (typeof markNav === 'function') markNav();
      },
      { passive: false }
    );

    window.addEventListener('mousemove', e=>{
      if(rightDownPos && !rightClickWasDrag){
        const d = Math.hypot(e.clientX-rightDownPos.x, e.clientY-rightDownPos.y);
        if(d>4) rightClickWasDrag=true;
      }
      if (viewMode === 'fps' && fpsPan.active) {
        const dx = e.clientX - fpsPan.x;
        const dy = e.clientY - fpsPan.y;
        fpsPan.x = e.clientX;
        fpsPan.y = e.clientY;
        const speed = 0.005 * (fp.movementSpeed / BASE_SPEED);
        camera.translateX(-dx * speed);
        camera.translateY(dy * speed);
      }
      if(!measuring) return;
      const x=e.clientX, y=e.clientY;
      updateLoupeAt(x,y);
      showCrosshair(x,y);
      if(pressed.size===0){
        if(mode==='distance'){
          if(chain.length>=1){
            const last=chain[chain.length-1];
            const hover=pick(x,y);
            if(hover){ previewLine.__a=last; previewLine.__b=hover; previewLine.__show=true; }
            else previewLine.__show=false;
          } else previewLine.__show=false;
        }else{
          if(polyPts.length>=1){
            const hover=pick(x,y);
            if(hover){ previewPoly.__pts=[...polyPts, hover]; previewPoly.__show=true; }
            else if(polyPts.length>=2){ previewPoly.__pts=[...polyPts]; previewPoly.__show=true; }
            else previewPoly.__show=false;
          } else previewPoly.__show=false;
        }
      }
    });

    const scanGroup = new THREE.Group(); scene.add(scanGroup);
    const scanGeom = new THREE.BufferGeometry();
    const scanMaterial = new THREE.PointsMaterial({ color:0x00ff99, size:3.0, sizeAttenuation:false, transparent:true, opacity:.95, depthWrite:false, blending:THREE.AdditiveBlending });
    const scanPointsMesh = new THREE.Points(scanGeom, scanMaterial); scanPointsMesh.frustumCulled=false; scanGroup.add(scanPointsMesh);
    let scanCount=0;
    scanGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0),3)); scanGeom.setDrawRange(0,0);

    const SCAN_MIN_STEP=0.12, SCAN_MAX_POINTS=8000, PROBE_DIST=2.0;
    const tmpV3=new THREE.Vector3(), lastPlotted=new THREE.Vector3(); let haveLast=false;

    function ensureCapacity(nextCount){
      const need = nextCount*3;
      const attr = scanGeom.getAttribute('position');
      if(attr.array.length >= need) return;
      const bigger = new Float32Array(Math.max(need, attr.array.length*2 || 1024));
      bigger.set(attr.array);
      scanGeom.setAttribute('position', new THREE.BufferAttribute(bigger,3));
    }
    function pushPoint(v){
      ensureCapacity(scanCount+1);
      const arr = scanGeom.getAttribute('position').array;
      const i = scanCount*3;
      arr[i]=v.x; arr[i+1]=v.y+0.01; arr[i+2]=v.z; scanCount++;
      if(scanCount>SCAN_MAX_POINTS){ arr.copyWithin(0,3,scanCount*3); scanCount=SCAN_MAX_POINTS; }
      scanGeom.setDrawRange(0,scanCount);
      scanGeom.attributes.position.needsUpdate=true; scanGeom.computeBoundingSphere();
    }
    function ndcDir(u,v){ const ndc=new THREE.Vector3(u,v,0.5); ndc.unproject(camera).sub(camera.position).normalize(); return ndc; }
    function getGroundPointAhead(){
      const camPos = camera.getWorldPosition(new THREE.Vector3());
      const dirCenter = ndcDir(0,0.15);
      let hit = lccObj.raycastFromOrigin({origin:{x:camPos.x,y:camPos.y,z:camPos.z}, direction:{x:dirCenter.x,y:dirCenter.y,z:dirCenter.z}, maxDistance:300, radius:0.05});
      if(hit) return new THREE.Vector3(hit.x,hit.y,hit.z);
      const probe = camPos.clone().addScaledVector(dirCenter, PROBE_DIST);
      hit = lccObj.raycastFromOrigin({origin:{x:probe.x,y:probe.y,z:probe.z}, direction:{x:0,y:-1,z:0}, maxDistance:300, radius:0.05});
      if(hit) return new THREE.Vector3(hit.x,hit.y,hit.z);
      return probe.add(new THREE.Vector3(0,-0.5,0));
    }
    function addScanPointIfNeeded(){
      if(!scanCheckbox.checked) return;
      const p = getGroundPointAhead();
      if(!haveLast){ lastPlotted.copy(p); haveLast=true; pushPoint(p); return; }
      if(p.distanceTo(lastPlotted)>=SCAN_MIN_STEP){
        tmpV3.copy(p).lerp(lastPlotted,0.15);
        pushPoint(tmpV3); lastPlotted.copy(tmpV3);
      }
    }
    const setScanVisible=(v)=>{ scanGroup.visible=v; }
    function clearScanPath(){ scanCount=0; haveLast=false; scanGeom.setDrawRange(0,0); scanGeom.attributes.position.needsUpdate=true; scanGeom.computeBoundingSphere(); }
    setScanVisible(false);
    scanCheckbox.addEventListener('click', e=>{ if(e.altKey) clearScanPath(); });

    const swCollision = $('sw-collision');
    let collisionEnabled = swCollision.classList.contains('on');
    swCollision.addEventListener('click', ()=>{
      collisionEnabled = !swCollision.classList.contains('on');
      toggleSwitch(swCollision, collisionEnabled);
    });

    // --- FIX 2: Increased collision radius to stop further away ---
    const COLLISION_RADIUS = 0.50;
    
    // ==========================================
    // UPDATED COLLISION LOGIC WITH SUB-STEPPING & MARGIN
    // ==========================================
    const __prevPos = new THREE.Vector3();

    function resolveCollision(){
      if (!collisionEnabled || !hasCollisionData) return;

      const startPos = __prevPos;
      const endPos = camera.position.clone();
      const dist = startPos.distanceTo(endPos);
      
      // Use a slightly smaller step size to ensure we don't skip thin walls
      const stepSize = COLLISION_RADIUS * 0.5; 
      const steps = Math.max(1, Math.ceil(dist / stepSize));
      const vecStep = new THREE.Vector3().subVectors(endPos, startPos).divideScalar(steps);
      
      let curr = startPos.clone();
      
      for(let i=0; i<steps; i++){
          curr.add(vecStep);
          
          const center = { x: curr.x, y: curr.y, z: curr.z };
          const res = lccObj.intersectsSphere({ center, radius: COLLISION_RADIUS, noDelta: false });
          
          if(res && res.hit && res.delta){
              // --- FIX 3: Add a 1% extra margin to the pushback ---
              // This ensures we don't sit exactly on the boundary and get stuck
              const margin = 1.01; 
              curr.x += res.delta.x * margin;
              curr.y += res.delta.y * margin;
              curr.z += res.delta.z * margin;
          }
      }
      
      camera.position.copy(curr);
    }

    function frame(){
      const dt = clock.getDelta();
      
      // Store position BEFORE movement
      __prevPos.copy(camera.position);

      if(fp.enabled){
        if(pressed.has('e')) camera.position.y += fp.movementSpeed * dt;
        if(pressed.has('q')) camera.position.y -= fp.movementSpeed * dt;
        
        // 1. Move camera based on inputs
        fp.update(dt);
        
        // 2. Resolve collisions immediately after movement
        resolveCollision();
      }
      
      if(orbit.enabled) orbit.update();
      
      addScanPointIfNeeded();
      LCCRender.update();
      updateOverlay();
      renderer.render(scene, camera);
      // Keep the loupe updated after the main render
      renderLoupeSample();
      gizmoRoot.quaternion.copy(camera.quaternion).invert();
      gizmoRenderer.render(gizmoScene, gizmoCamera);
    }
    renderer.setAnimationLoop(frame);

   // window.addEventListener('keydown', e=>{
    //  if(e.key==='Escape'){ clearAll(); clearScanPath(); const el=$('help'); if(el.classList.contains('open')) el.classList.remove('open'); }
    //  if(e.key.toLowerCase()==='m') $('btn-measure').click();
   //   if(e.key.toLowerCase()==='h'){
   //     const ui=document.querySelector('.ui');
   //     ui.style.display = ui.style.display==='none' ? '' : 'none';
   //   }
    //  if(e.key.toLowerCase()==='p'){ setViewMode(viewMode==='pivot' ? 'fps' : 'pivot'); }
    //});
  </script>

<!-- Password gate modal -->
<div id="pwd-modal" class="pwd-modal" aria-hidden="true">
  <div class="pwd-card" role="dialog" aria-label="Password required">
    <header>
      <div id="pwd-title">Password required</div>
    </header>
    <div class="body">
      <label for="pwd-input">Password</label>
      <input id="pwd-input" type="password" autocomplete="current-password" />
      <div class="pwd-hint" id="pwd-hint"></div>
      <div class="pwd-error" id="pwd-error"></div>
      <div class="pwd-actions">
        <button class="pwd-btn" id="pwd-cancel" type="button">Cancel</button>
        <button class="pwd-btn primary" id="pwd-ok" type="button">Unlock</button>
      </div>
    </div>
  </div>
</div>

<!-- Locked / error overlay -->
<div id="lock-msg" class="lock-msg" aria-hidden="true">
  <div class="inner">
    <div class="lock-msg-text">Password required to open this file.</div>
  </div>
</div>
</body>
</html>
